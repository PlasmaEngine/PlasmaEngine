// MIT Licensed (see LICENSE.md).

#pragma once

namespace Plasma
{
namespace Tags
{
DeclareTag(Sound);
} // namespace Tags

namespace Events
{

DeclareEvent(MIDINoteOn);
DeclareEvent(MIDINoteOff);
DeclareEvent(MIDIPitchWheel);
DeclareEvent(MIDIVolume);
DeclareEvent(MIDIModWheel);
DeclareEvent(MIDIOtherControl);
DeclareEvent(SoundInstancePlayed);
DeclareEvent(MicrophoneUncompressedFloatData);
DeclareEvent(MicrophoneCompressedByteData);

} // namespace Events

// Sound Event

/// Sent for various audio-related events
class SoundEvent : public Event
{
public:
  LightningDeclareType(SoundEvent, TypeCopyMode::ReferenceType);

  SoundEvent() : mPointer(nullptr)
  {
  }
  SoundEvent(void* pointer) : mPointer(pointer)
  {
  }

  void* mPointer;
};

// MIDI Event

/// Sent when a MIDI message is received from a connected device.
class MidiEvent : public Event
{
public:
  LightningDeclareType(MidiEvent, TypeCopyMode::ReferenceType);

  MidiEvent() : Channel(0), MIDINumber(0), Value(0)
  {
  }
  MidiEvent(float channel, float number, float value) : Channel(channel), MIDINumber(number), Value(value)
  {
  }

  /// The MIDI channel received from the device.
  float Channel;
  /// The MIDI note number associated with the message.
  float MIDINumber;
  /// A value associated with the message. Will be in the range 0 - 127.
  float Value;
};

// Audio Float Data Event

class AudioFloatDataEvent : public Event
{
public:
  LightningDeclareType(AudioFloatDataEvent, TypeCopyMode::ReferenceType);

  HandleOf<ArrayClass<float>> AudioData;
  unsigned Channels;
};

// Audio Byte Data Event

class AudioByteDataEvent : public Event
{
public:
  LightningDeclareType(AudioByteDataEvent, TypeCopyMode::ReferenceType);

  HandleOf<ArrayClass<::byte>> AudioData;
};

// Enums

/// The possible settings for the number of channels used by the audio system
/// when creating audio. <param name="AutoDetect">The audio system will match
/// its channels to the default output device.</param> <param name="Mono">Audio
/// will be produced using only a single channel.</param> <param
/// name="Stereo">Audio will be produced using two channels, one for the left
/// speaker and one for the right.</param> <param name="Quad">Audio will be
/// produced using two left channels and two right channels.</param> <param
/// name="FiveOne">Audio will be produced using a typical 5.1 speaker
/// configuration.</param> <param name="SevenOne">Audio will be produced using a
/// typical 7.1 speaker configuration.</param>
DeclareEnum6(AudioMixTypes, AutoDetect, Mono, Stereo, Quad, FiveOne, SevenOne);

// Sound System

/// SoundSystem manages audio for the engine.
class SoundSystem : public System
{
public:
  LightningDeclareType(SoundSystem, TypeCopyMode::ReferenceType);

  SoundSystem();
  ~SoundSystem();

  // System Interface
  virtual cstr GetName() override
  {
    return "Sound";
  }
  void Initialize(SystemInitializer& initializer) override;

  /// Used by the SoundNode Graph window to display the current state of
  /// connected SoundNodes.
  NodeInfoListType::range GetNodeGraphInfo();
  /// The volume modifier applied to all audio generated by Plasma.
  float GetSystemVolume();
  void SetSystemVolume(float volume);
  /// When true, audio will be processed normally but will be silent.
  bool GetMuteAllAudio();
  void SetMuteAllAudio(bool muteAudio);
  /// The current peak volume level of all audio output
  float GetPeakOutputLevel();
  /// The current RMS volume level of all audio output
  float GetRMSOutputLevel();
  /// If currently dispatching either uncompressed or compressed audio input
  /// data, this value will be the highest peak volume in the last batch of
  /// input.
  float GetPeakInputLevel();
  /// Using the high latency setting can fix some audio problems (such as clicks
  /// and static) but can lead to a slight delay in the audio
  AudioLatency::Enum GetLatencySetting();
  void SetLatencySetting(AudioLatency::Enum latency);
  /// If true, MicrophoneUncompressedFloatData events will be sent every update
  /// with the buffer of audio data received from the default audio input
  /// device.
  bool GetDispatchMicrophoneUncompressedFloatData();
  void SetDispatchMicrophoneUncompressedFloatData(bool dispatchData);
  /// If true, MicrophoneCompressedByteData events will be sent every update
  /// with the buffer of compressed audio data received from the default audio
  /// input device.
  bool GetDispatchMicrophoneCompressedByteData();
  void SetDispatchMicrophoneCompressedByteData(bool dispatchData);
  /// Returns the number of audio channels currently used by the audio engine
  /// for audio output.
  int GetOutputChannels();

  /// Creates a new VolumeNode object
  static VolumeNode* VolumeNode();
  /// Creates a new PanningNode object
  static PanningNode* PanningNode();
  /// Creates a new PitchNode object
  static PitchNode* PitchNode();
  /// Creates a new LowPassNode object
  static LowPassNode* LowPassNode();
  /// Creates a new HighPassNode object
  static HighPassNode* HighPassNode();
  /// Creates a new BandPassNode object
  static BandPassNode* BandPassNode();
  /// Creates a new EqualizerNode object
  static EqualizerNode* EqualizerNode();
  /// Creates a new ReverbNode object
  static ReverbNode* ReverbNode();
  /// Creates a new DelayNode object
  static DelayNode* DelayNode();
  /// Creates a new FlangerNode object
  static FlangerNode* FlangerNode();
  /// Creates a new ChorusNode object
  static ChorusNode* ChorusNode();
  /// Creates a new CompressorNode object
  static CompressorNode* CompressorNode();
  /// Creates a new ExpanderNode object
  static ExpanderNode* ExpanderNode();
  /// Creates a new CustomAudioNode object
  static CustomAudioNode* CustomAudioNode();
  /// Creates a new SoundBuffer object
  static SoundBuffer* SoundBuffer();
  /// Creates a new GeneratedWaveNode object
  static GeneratedWaveNode* GeneratedWaveNode();
  /// Creates a new RecordingNode object
  static RecordingNode* RecordingNode();
  /// Creates a new AddNoiseNode object
  static AddNoiseNode* AddNoiseNode();
  /// Creates a new AdditiveSynthNode object
  static AdditiveSynthNode* AdditiveSynthNode();
  /// Creates a new ModulationNode object
  static ModulationNode* ModulationNode();
  /// Creates a new MicrophoneInputNode object
  static MicrophoneInputNode* MicrophoneInputNode();
  /// Creates a new SaveAudioNode object
  static SaveAudioNode* SaveAudioNode();
  /// Creates a new GranularSynthNode object
  static GranularSynthNode* GranularSynthNode();

  /// If true, the random number generator used by audio objects in this
  /// SoundSpace will be seeded randomly.
  bool mUseRandomSeed;
  /// Value to seed the random number generator with.
  uint mSeed;

  // Internals
  void Update(bool debugger) override;
  void StopPreview();
  void AddSoundSpace(SoundSpace* space, bool isEditor);
  void RemoveSoundSpace(SoundSpace* space, bool isEditor);

  AudioMixer Mixer;

  unsigned mCounter;
  InList<SoundTag> mSoundTags;
  HandleOf<SoundInstance> mPreviewInstance;
  String mAudioMessage;
  SoundNodeGraph NodeGraph;
  HandleOf<CombineNode> mOutputNode;
  int mSoundSpaceCounter;
  Math::Random mRandom;

private:
  AudioLatency::Enum mLatency;
  bool mSendMicEvents;
  bool mSendCompressedMicEvents;
  InList<SoundSpace> mSpaces;

  friend class AudioSettings;
  friend class AudioStatics;
};

System* CreateSoundSystem();

// Global Access
namespace PL
{
extern SoundSystem* gSound;
} // namespace PL

// Sound Settings

class AudioSettings : public Component
{
public:
  LightningDeclareType(AudioSettings, TypeCopyMode::ReferenceType);

  AudioSettings();

  void Serialize(Serializer& stream) override;
  void Initialize(CogInitializer& initializer) override;

  /// An overall volume modifier that is applied to all audio produced by Plasma.
  float GetSystemVolume();
  void SetSystemVolume(float volume);
  /// When true, audio will be processed normally but will be silent.
  bool GetMuteAllAudio();
  void SetMuteAllAudio(bool muteAudio);
  /// Sets the number of channels the audio system uses when creating audio. See
  /// the enum descriptions. If your selection is different from the output
  /// device, it will be automatically translated to match the number of
  /// channels needed for output.
  AudioMixTypes::Enum GetMixType();
  void SetMixType(AudioMixTypes::Enum mixType);
  /// Sets the volume threshold at which sounds will be virtualized (they will
  /// continue tracking their position and all data but will not process audio).
  /// This is a floating point volume number, not decibels.
  float GetMinVolumeThreshold();
  void SetMinVolumeThreshold(float volume);
  /// Using the high latency setting can fix some audio problems (such as clicks
  /// and static) but can lead to a slight delay in the audio
  AudioLatency::Enum GetLatencySetting();
  void SetLatencySetting(AudioLatency::Enum latency);
  /// If true, the random number generator used by audio objects in this
  /// SoundSpace will be seeded randomly.
  bool GetUseRandomSeed();
  void SetUseRandomSeed(bool useRandom);
  /// Value to seed the random number generator with.
  uint GetSeed();
  void SetSeed(uint seed);

private:
  float mSystemVolume;
  float mMinVolumeThreshold;
  AudioMixTypes::Enum mMixType;
  AudioLatency::Enum mLatency;
  bool mUseRandomSeed;
  uint mSeed;
};

} // namespace Plasma
