// MIT Licensed (see LICENSE.md).

// Renders geometric and material data of opaque objects and defers lighting for a separate pass.
// Allow processing of an arbitrary number of dynamic area lights with minimal performance penalty.
[RunInEditor]
class DeferredRenderer : LightningComponent
{
  // Cubemap Texture to use for indirect lighting and/or scene background. Undefined behavior if null or not a cubemap.
  [Group("Settings")]
  [Property] var Skybox : Texture = Texture.SimpleSkybox;
  // The Main Light for the level
  [Group("Settings")]
  [Property] var MainLight : CogPath = null;
  // Color for the background if not using the skybox.
  [Group("Settings")]
  [Property] var ClearColor : Real4 = Real4(0.0, 0.0, 0.0, 1.0);
  // Toggles output of dynamic area lights.
  [Group("Settings")]
  [Property] var DirectLighting : Boolean = true;
  // Toggles output of the image-based lighting pass that uses the skybox.
  [Group("Settings")]
  [Property] var IndirectLighting : Boolean = true;
  // Arbitrary scalar for the output of IndirectLighting.
  [Group("Settings")]
  [Property] var IndirectIntensity : Real = 1.0;
  [Group("Settings")]
  [Property] var MaxIntensity : Real = 50.0;
  // If a filmic tonemap should be used when converting lighting results from linear to gamma for monitor display.
  [Group("Settings")]
  [Property] var ToneMap : Boolean = true;
  // Outputs values from the geometry pass for debugging.
  [Group("Debug")]
  [Property] var GeometryDebug : GeometryValue = GeometryValue.None;
  // If DebugDraw RenderGroups are drawn in edit mode.
  [Group("Debug")]
  [Property] var EditorDebugDraw : Boolean = true;
  // If DebugDraw RenderGroups are drawn in play mode.
  [Group("Debug")]
  [Property] var GameDebugDraw : Boolean = true;
  // Toggles diffuse light output.
  [Group("Debug")]
  [Property] var RenderDiffuse : Boolean = true;
  // Toggles specular light output.
  [Group("Debug")]
  [Property] var RenderSpecular : Boolean = true;
  // If skybox should be used for the background, uses ClearColor for background if false.
  [Group("Debug")]
  [Property] var RenderSkybox : Boolean = true;
  
  var GBufferNormalDepthRoughnessRT : RenderTarget;
  var GBufferAlbedoMetallicSpec : RenderTarget;
  var GBufferEmissiveAO : RenderTarget;
  
  var Depth : RenderTarget;
  var VelPosBuffer : RenderTarget;
  var SSRBuffer : RenderTarget;
  
  var LastFrame : RenderTarget;
  
  var FinalOutput : RenderTarget;
  
  var SSRTexture : Texture;
  
  var FirstFrame : Boolean;
  
  function Initialize(init : CogInitializer)
  {
    this.FirstFrame = true;
    
    Plasma.Connect(this.Owner, Events.RenderTasksUpdate, this.OnRenderTasksUpdate);
    Plasma.Connect(this.Space, Events.DebugViewMode, this.OnDebugViewChange);

    
    //this.SSRTexture = Texture.CreateRuntime();
    //this.SSRTexture.Upload(TextureFormat.RGBA8, viewportSize.X, viewportSize.Y);
  } 
   
  function OnDebugViewChange(event: DebugViewEvent)
  {
    this.GeometryDebug = event.Mode as GeometryValue;
  }
  
  function ResizeBuffers(event : RenderTasksEvent)
  {
    var viewportSize = event.ViewportSize;
    
    this.FinalOutput = event.GetFinalTarget(viewportSize, TextureFormat.RGBA8);
    
    this.GBufferNormalDepthRoughnessRT = event.GetRenderTarget(viewportSize, TextureFormat.RGBA32f);
    this.GBufferAlbedoMetallicSpec = event.GetRenderTarget(viewportSize, TextureFormat.RGBA16f);
    this.GBufferEmissiveAO = event.GetRenderTarget(viewportSize, TextureFormat.RGBA16f);
    
    this.Depth = event.GetRenderTarget(viewportSize, TextureFormat.Depth24Stencil8);
    
    this.VelPosBuffer = event.GetRenderTarget(viewportSize, TextureFormat.RGBA16f);
        
    this.LastFrame = event.GetRenderTarget(viewportSize, TextureFormat.RGBA8);
    
    var ssrSamplerSettings = SamplerSettings() {Filtering = TextureFiltering.Bilinear};
    this.SSRBuffer = event.GetRenderTarget(viewportSize, TextureFormat.RGBA16f, ssrSamplerSettings);
          
      
  }

  function OnRenderTasksUpdate(event : RenderTasksEvent)
  {      
    var viewportSize = event.ViewportSize;
    
    this.ResizeBuffers(event);
        
    var geometryPassSettings = RenderSettings();
    geometryPassSettings.MultiRenderTarget.ColorTarget0 = this.GBufferNormalDepthRoughnessRT;
    geometryPassSettings.MultiRenderTarget.ColorTarget1 = this.GBufferAlbedoMetallicSpec;
    geometryPassSettings.MultiRenderTarget.ColorTarget2 = this.GBufferEmissiveAO;
    geometryPassSettings.DepthTarget = this.Depth;
    
    geometryPassSettings.DepthSettings.DepthMode = DepthMode.Write;
    geometryPassSettings.DepthSettings.DepthCompareFunc = TextureCompareFunc.LessEqual;
    // Using stencil buffer to optimally identify which pixels had opaque objects rendered to them
    geometryPassSettings.DepthSettings.StencilMode = StencilMode.Enabled;
    geometryPassSettings.DepthSettings.StencilCompareFunc = TextureCompareFunc.Always;
    geometryPassSettings.DepthSettings.StencilFailOp = StencilOp.Keep;
    geometryPassSettings.DepthSettings.DepthFailOp = StencilOp.Keep;
    geometryPassSettings.DepthSettings.DepthPassOp = StencilOp.Replace;
    geometryPassSettings.DepthSettings.StencilTestValue = 1 as Byte;
    
    // Clearing depth to 1 (the farplane) the way it is currently stored, and normals to +z
    event.AddRenderTaskClearTarget(geometryPassSettings, Real4(0.0, 0.0, 1.0, 1.0), 1.0, 0);
    
    
    
    ////////////////////////////////////////////////
    geometryPassSettings.CullMode = CullMode.BackFace;
    event.AddRenderTaskRenderPass(geometryPassSettings, RenderGroup.Opaque, GeometryPass(), "OpaqueGeom");
    
    geometryPassSettings.CullMode = CullMode.Disabled;
    event.AddRenderTaskRenderPass(geometryPassSettings, RenderGroup.OpaqueDoubleSided, GeometryPass(), "DoubleSidedGeom");
    
    // Lighting
    var lightBuffer = event.GetRenderTarget(viewportSize, TextureFormat.RGBA16f);
    event.AddRenderTaskClearTarget(lightBuffer, Real4(0.0, 0.0, 0.0, 1.0));
    
    var lightSettings = RenderSettings();
    lightSettings.ColorTarget = lightBuffer;
    lightSettings.DepthTarget = this.Depth;
    
    // Only process background pixels
    lightSettings.DepthSettings.StencilMode = StencilMode.Enabled;
    lightSettings.DepthSettings.StencilCompareFunc = TextureCompareFunc.Equal;
    lightSettings.DepthSettings.StencilFailOp = StencilOp.Keep;
    lightSettings.DepthSettings.DepthFailOp = StencilOp.Keep;
    lightSettings.DepthSettings.DepthPassOp = StencilOp.Keep;
    lightSettings.DepthSettings.StencilTestValue = 0 as Byte;
    
    if (this.RenderSkybox && this.Skybox != null && this.Skybox.Type == TextureType.TextureCube)
    {
      var skybox = Skybox();
      skybox.Skybox = this.Skybox;
    
      event.AddRenderTaskPostProcess(lightSettings, skybox, "Skybox");
    }
    else
    {
      var copyValue = CopyValue();
      copyValue.Color = Math.Pow(this.ClearColor, Real4(2.2.XXX, 1.0));
      event.AddRenderTaskPostProcess(lightSettings, copyValue, "SkyboxColor");
    }
    
        var velocityBuffer = VelocityBuffer();
    velocityBuffer.FirstFrame = this.FirstFrame;
    event.AddRenderTaskPostProcess(this.VelPosBuffer, velocityBuffer, "VelocityBuffer");
    
    // Only process opaque pixels
    lightSettings.DepthSettings.StencilTestValue = 1 as Byte;
    
    if (this.GeometryDebug != GeometryValue.None)
    {
      // Bring skybox to gamma space for monitor display
      this.LinearToGamma(event, lightBuffer, this.FinalOutput);
      
      var geometryDebug = GeometryDebug();
      geometryDebug.GeometryBuffer0 = this.GBufferNormalDepthRoughnessRT.Texture;
      geometryDebug.GeometryBuffer1 = this.GBufferAlbedoMetallicSpec.Texture;
      geometryDebug.GeometryBuffer2 = this.GBufferEmissiveAO.Texture;
      
      if (this.GeometryDebug == GeometryValue.Normal)
        geometryDebug.ShowNormal = true;
      else if (this.GeometryDebug == GeometryValue.Depth)
        geometryDebug.ShowDepth = true;
      else if (this.GeometryDebug == GeometryValue.Roughness)
        geometryDebug.ShowRoughness = true;
      else if (this.GeometryDebug == GeometryValue.Albedo)
        geometryDebug.ShowAlbedo = true;
      else if (this.GeometryDebug == GeometryValue.Metallic)
        geometryDebug.ShowMetallic = true;
      else if (this.GeometryDebug == GeometryValue.Specular)
        geometryDebug.ShowSpecular = true;
      else if (this.GeometryDebug == GeometryValue.Emissive)
        geometryDebug.ShowEmissive = true;
      else if (this.GeometryDebug == GeometryValue.AO)
        geometryDebug.ShowAO = true;
      
      var geometryDebugSettings = RenderSettings();
      geometryDebugSettings.ColorTarget = this.FinalOutput;
      geometryDebugSettings.DepthTarget = this.Depth;
      geometryDebugSettings.DepthSettings = lightSettings.DepthSettings;
      
      event.AddRenderTaskPostProcess(geometryDebugSettings, geometryDebug, "GeometryDebug");
      
      this.DrawDebugObjects(event, this.FinalOutput, this.Depth);
        
      return;
    }
      
    if (this.IndirectLighting)
    {
      var imageBasedLighting = ImageBasedLighting();
      imageBasedLighting.DitherTexture = Texture.BlueNoise;
      imageBasedLighting.EnvironmentBrdfLut = Texture.EnvironmentBrdfLut;
      imageBasedLighting.Skybox = this.Skybox;
      imageBasedLighting.Intensity = this.IndirectIntensity;
      imageBasedLighting.MaxIntensity = this.MaxIntensity;
      imageBasedLighting.GeometryBuffer0 = this.GBufferNormalDepthRoughnessRT.Texture;
      imageBasedLighting.GeometryBuffer1 = this.GBufferAlbedoMetallicSpec.Texture;
      imageBasedLighting.RenderDiffuse = this.RenderDiffuse;
      imageBasedLighting.RenderSpecular = this.RenderSpecular;
    
      event.AddRenderTaskPostProcess(lightSettings, imageBasedLighting, "ImageBasedLighting");
    }
    
    // Ssao
    if (this.Owner.Ssao != null)
    {
      this.Owner.Ssao.AddRenderTasks(event, lightBuffer, this.GBufferNormalDepthRoughnessRT);
      if (this.Owner.Ssao.DebugBuffer && this.Owner.Ssao.Active)
      {
        // Don't do any other lighting if debugging ssao buffer
        this.LinearToGamma(event, lightBuffer, this.FinalOutput);
        this.DrawDebugObjects(event, this.FinalOutput, this.Depth);
        return;
      }
    }
    
    if (this.DirectLighting)
    {
      var geometryInputs = ShaderInputs.Create();
      geometryInputs.Add("GeometryInput", "GeometryBuffer0", this.GBufferNormalDepthRoughnessRT.Texture);
      geometryInputs.Add("GeometryInput", "GeometryBuffer1", this.GBufferAlbedoMetallicSpec.Texture);
      geometryInputs.Add("GeometryInput", "GeometryBuffer2", this.GBufferEmissiveAO.Texture);
      
      lightSettings.GlobalShaderInputs = geometryInputs;
      lightSettings.CullMode = CullMode.FrontFace;
      lightSettings.BlendSettings.BlendMode = BlendMode.Enabled;
      lightSettings.BlendSettings.BlendEquation = BlendEquation.Add;
      lightSettings.BlendSettings.SourceFactor = BlendFactor.One;
      lightSettings.BlendSettings.DestFactor = BlendFactor.One;
      lightSettings.DepthSettings.DepthMode = DepthMode.Read;
      lightSettings.DepthSettings.DepthCompareFunc = TextureCompareFunc.GreaterEqual;
      
      var lightPass = LightPass();
      lightPass.DitherTexture = Texture.BlueNoise;
      lightPass.RenderDiffuse = this.RenderDiffuse;
      lightPass.RenderSpecular = this.RenderSpecular;
      
      event.AddRenderTaskRenderPass(lightSettings, RenderGroup.Lights, lightPass, "DirectLighting");
    }
    
    // Additive materials
    var alphaSettings = RenderSettings();
    alphaSettings.ColorTarget = lightBuffer;
    alphaSettings.DepthTarget = this.Depth;
    alphaSettings.CullMode = CullMode.Disabled;
    alphaSettings.BlendSettings.BlendMode = BlendMode.Separate;
    alphaSettings.BlendSettings.BlendEquation = BlendEquation.Add;
    alphaSettings.BlendSettings.SourceFactor = BlendFactor.SourceAlpha;
    alphaSettings.BlendSettings.DestFactor = BlendFactor.One;
    alphaSettings.BlendSettings.SourceFactorAlpha = BlendFactor.One;
    alphaSettings.BlendSettings.DestFactorAlpha = BlendFactor.One;
    alphaSettings.DepthSettings.DepthMode = DepthMode.Read;
    alphaSettings.DepthSettings.DepthCompareFunc = TextureCompareFunc.LessEqual;
    event.AddRenderTaskRenderPass(alphaSettings, RenderGroup.AdditiveBlend, ColorOutput(), "AdditiveMaterials");
  
    event.AddRenderTaskClearTarget(this.SSRBuffer, Real4.Zero);
    
    // Screen Space Reflections
    if(this.Owner.PostProcessSSR != null)
    {
      this.Owner.PostProcessSSR.AddSSRRenderTasks(event, this.GBufferNormalDepthRoughnessRT, this.GBufferAlbedoMetallicSpec, lightBuffer, this.SSRBuffer);
    }
    
    // Bloom
    if (this.Owner.Bloom != null)
      this.Owner.Bloom.AddRenderTasks(event, lightBuffer);
      

    
    // Bring final lighting to gamma space for monitor display
    this.LinearToGamma(event, lightBuffer, this.FinalOutput);
    
    if(this.Owner.PostProcessTAA != null)
      this.Owner.PostProcessTAA.AddRenderTasks(event, this.FinalOutput, this.LastFrame, this.VelPosBuffer, this.Depth, this.FirstFrame as Integer);
    
    // FXAA
    if(this.Owner.PostProcessFXAA != null)
        this.Owner.PostProcessFXAA.AddRenderTasks(event, this.FinalOutput);
        
    // Alpha materials
    alphaSettings.ColorTarget = this.FinalOutput;
    alphaSettings.BlendSettings.DestFactor = BlendFactor.InvSourceAlpha;
    event.AddRenderTaskRenderPass(alphaSettings, RenderGroup.AlphaBlend, AlphaPass(), "AlphaMaterials");
    
    this.FirstFrame = false;
    
    this.DrawDebugObjects(event, this.FinalOutput, this.Depth);
  }
  
  function LinearToGamma(event : RenderTasksEvent, inputBuffer : RenderTarget, outputBuffer : RenderTarget)
  {
    if (this.ToneMap)
    {
      var filmicToneMap = FilmicTonemap();
      filmicToneMap.Texture = inputBuffer.Texture;
      event.AddRenderTaskPostProcess(outputBuffer, filmicToneMap, "FilmicTonemapping");
    }
    else
    {
      var toGamma = ToGamma();
      toGamma.Texture = inputBuffer.Texture;
      event.AddRenderTaskPostProcess(outputBuffer, toGamma, "ToGamma");
    }
  }
  
  function DrawDebugObjects(event : RenderTasksEvent, color : RenderTarget, depth : RenderTarget)
  {
    if (!this.EditorDebugDraw && this.Space.IsEditorMode || !this.GameDebugDraw && !this.Space.IsEditorMode)
      return;
    
    var debugSettings = RenderSettings();
    debugSettings.ColorTarget = color;
    debugSettings.DepthTarget = depth;
    
    debugSettings.CullMode = CullMode.Disabled;
    
    debugSettings.BlendSettings.BlendMode = BlendMode.Separate;
    debugSettings.BlendSettings.BlendEquation = BlendEquation.Add;
    debugSettings.BlendSettings.SourceFactor = BlendFactor.SourceAlpha;
    debugSettings.BlendSettings.DestFactor = BlendFactor.InvSourceAlpha;
    debugSettings.BlendSettings.SourceFactorAlpha = BlendFactor.One;
    debugSettings.BlendSettings.DestFactorAlpha = BlendFactor.One;
    
    debugSettings.DepthSettings.DepthMode = DepthMode.Read;
    debugSettings.DepthSettings.DepthCompareFunc = TextureCompareFunc.LessEqual;
    
    event.AddRenderTaskRenderPass(debugSettings, RenderGroup.DebugDraw, ColorOutput(), "DebugDraw");
    
    debugSettings.DepthSettings.DepthMode = DepthMode.Disabled;
    event.AddRenderTaskRenderPass(debugSettings, RenderGroup.DebugDrawOnTop, ColorOutput(), "DebugDrawOnTop");
  }
}